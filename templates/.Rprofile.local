# ============================================================================
# Terminal Graphics Support - Kitty and iTerm2
# ============================================================================
# This file provides automatic plot display in modern terminal emulators.
# It sources automatically if present in zzcollab workspaces.
# Copy to workspace root: cp ~/.Rprofile.local .Rprofile.local

# ============================================================================
# Terminal Detection
# ============================================================================
.terminal_type <- function() {
  if (Sys.getenv("KITTY_WINDOW_ID") != "") {
    return("kitty")
  } else if (Sys.getenv("ITERM_SESSION_ID") != "" ||
             grepl("iTerm", Sys.getenv("TERM_PROGRAM"), ignore.case = TRUE)) {
    return("iterm2")
  } else {
    return("none")
  }
}

.is_docker <- function() {
  Sys.getenv("ZZCOLLAB_CONTAINER") == "true"
}

.terminal <- .terminal_type()

# Only activate on supported macOS or Linux terminals
if (.terminal != "none" && (Sys.info()["sysname"] %in% c("Darwin", "Linux"))) {

  # ========================================================================
  # Configuration
  # ========================================================================
  assign(".plot_width", 900, envir = .GlobalEnv)
  assign(".plot_height", 700, envir = .GlobalEnv)
  assign(".plot_res", 96, envir = .GlobalEnv)
  assign(".plot_align", "right", envir = .GlobalEnv)
  assign(".plot_file", NULL, envir = .GlobalEnv)
  assign(".plot_history", list(), envir = .GlobalEnv)
  assign(".plot_history_idx", 0, envir = .GlobalEnv)
  assign(".use_relative_sizing", FALSE, envir = .GlobalEnv)
  assign(".width_pct", 0.75, envir = .GlobalEnv)
  assign(".height_pct", 1.0, envir = .GlobalEnv)

  # ========================================================================
  # Device Creation
  # ========================================================================
  .create_plot_device <- function() {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (!is.null(pf) && file.exists(pf)) {
      unlink(pf)
    }

    pf <- tempfile(pattern = "plot_", fileext = ".png")
    assign(".plot_file", pf, envir = .GlobalEnv)

    # If using relative sizing, recalculate
    use_relative <- get(".use_relative_sizing", envir = .GlobalEnv)
    if (use_relative) {
      cols_str <- system("tput cols", intern = TRUE, ignore.stderr = TRUE)
      lines_str <- system("tput lines", intern = TRUE, ignore.stderr = TRUE)

      if (length(cols_str) > 0 && length(lines_str) > 0) {
        cols <- as.numeric(cols_str[1])
        lines <- as.numeric(lines_str[1])
        width_pct <- get(".width_pct", envir = .GlobalEnv)
        height_pct <- get(".height_pct", envir = .GlobalEnv)

        width <- floor(cols * 8 * width_pct)
        height <- floor(lines * 16 * height_pct)
      } else {
        width <- get(".plot_width", envir = .GlobalEnv)
        height <- get(".plot_height", envir = .GlobalEnv)
      }
    } else {
      width <- get(".plot_width", envir = .GlobalEnv)
      height <- get(".plot_height", envir = .GlobalEnv)
    }

    res <- get(".plot_res", envir = .GlobalEnv)
    grDevices::png(filename = pf, width = width, height = height, res = res)
  }

  assign(".create_plot_device", .create_plot_device, envir = .GlobalEnv)

  # ========================================================================
  # Display Plot
  # ========================================================================
  # Plot display mode: "inline", "pane", or "auto"
  # - inline: display in current terminal (default for standalone kitty)
  # - pane: always use dedicated plot pane (reused across plots)
  # - auto: try inline first, fall back to pane if inside vim terminal
  assign(".plot_display_mode", "pane", envir = .GlobalEnv)
  assign(".plot_pane_title", "zzvim-plot", envir = .GlobalEnv)
  assign(".kitty_remote_warned", FALSE, envir = .GlobalEnv)

  # Check if kitty remote control is enabled
  .kitty_remote_enabled <- function() {
    result <- suppressWarnings(
      system("kitty @ ls >/dev/null 2>&1", ignore.stdout = TRUE, ignore.stderr = TRUE)
    )
    return(result == 0)
  }

  # Check if a kitty window with given title exists
  .kitty_window_exists <- function(title) {
    result <- suppressWarnings(
      system(paste("kitty @ ls 2>/dev/null | grep -q", shQuote(title)),
             ignore.stdout = TRUE, ignore.stderr = TRUE)
    )
    return(result == 0)
  }

  assign(".kitty_remote_enabled", .kitty_remote_enabled, envir = .GlobalEnv)

  # Display plot in a dedicated kitty pane (reused across plots)
  .display_in_pane <- function(pf) {
    # Check if kitty remote control is available
    if (!.kitty_remote_enabled()) {
      warned <- get(".kitty_remote_warned", envir = .GlobalEnv)
      if (!warned) {
        cat("\n")
        cat("WARNING: Kitty remote control not enabled.\n")
        cat("Plot pane mode requires 'allow_remote_control yes' in kitty.conf\n")
        cat("Add this line to ~/.config/kitty/kitty.conf and restart kitty.\n")
        cat("Falling back to inline display.\n\n")
        assign(".kitty_remote_warned", TRUE, envir = .GlobalEnv)
      }
      # Fall back to inline display
      align <- get(".plot_align", envir = .GlobalEnv)
      suppressWarnings(
        system(paste("kitty +kitten icat --align=", align, " ", shQuote(pf), sep = ""),
               ignore.stderr = TRUE, ignore.stdout = TRUE)
      )
      return(invisible(NULL))
    }

    pane_title <- get(".plot_pane_title", envir = .GlobalEnv)

    if (.kitty_window_exists(pane_title)) {
      # Pane exists - clear it and display new plot
      # Send Ctrl+C to interrupt any running process, then clear and show new image
      system(paste0(
        "kitty @ send-text --match title:", pane_title,
        " '\\x03' 2>/dev/null"
      ), ignore.stderr = TRUE, ignore.stdout = TRUE)

      # Small delay to let Ctrl+C take effect
      Sys.sleep(0.1)

      # Send command to clear and display new plot
      cmd <- paste0("clear && kitty +kitten icat --clear && ",
                    "kitty +kitten icat --scale-up ", shQuote(pf),
                    " && read -r -d '' _ </dev/tty")
      system(paste0(
        "kitty @ send-text --match title:", pane_title,
        " ", shQuote(paste0(cmd, "\n"))
      ), ignore.stderr = TRUE, ignore.stdout = TRUE)
    } else {
      # Create new pane with title for future reuse
      # The pane runs a loop that displays images and waits
      shell_cmd <- paste0(
        "kitty @ launch --location=vsplit --keep-focus ",
        "--title ", shQuote(pane_title), " ",
        "-- sh -c ", shQuote(paste0(
          "kitty +kitten icat --scale-up ", shQuote(pf),
          "; read -r -d '' _ </dev/tty"
        ))
      )
      system(shell_cmd, ignore.stderr = TRUE, ignore.stdout = TRUE)
    }
  }

  assign(".kitty_window_exists", .kitty_window_exists, envir = .GlobalEnv)
  assign(".display_in_pane", .display_in_pane, envir = .GlobalEnv)

  .display_plot <- function(pf) {
    if (!is.null(pf) && file.exists(pf)) {
      align <- get(".plot_align", envir = .GlobalEnv)
      terminal <- get(".terminal", envir = .GlobalEnv)
      in_docker <- .is_docker()
      display_mode <- get(".plot_display_mode", envir = .GlobalEnv)

      # Docker mode: save to .plots/ for host-side vim watcher to display
      if (in_docker) {
        plots_dir <- ".plots"
        if (!dir.exists(plots_dir)) dir.create(plots_dir, showWarnings = FALSE)
        target_file <- file.path(plots_dir, "current.png")
        file.copy(pf, target_file, overwrite = TRUE)
      } else if (terminal == "kitty") {
        if (display_mode == "pane") {
          # Always use dedicated pane
          .display_in_pane(pf)
        } else if (display_mode == "inline") {
          # Always try inline
          suppressWarnings(
            system(paste("kitty +kitten icat --align=", align, " ", shQuote(pf), sep = ""),
                   ignore.stderr = TRUE, ignore.stdout = TRUE)
          )
        } else {
          # Auto mode: try inline first, fall back to pane
          result <- suppressWarnings(
            system(paste("kitty +kitten icat --align=", align, " ", shQuote(pf), sep = ""),
                   ignore.stderr = TRUE, ignore.stdout = TRUE)
          )
          if (result != 0) {
            .display_in_pane(pf)
          }
        }
      } else if (terminal == "iterm2") {
        system(paste("imgcat", shQuote(pf)), ignore.stderr = TRUE)
      }

      # Store terminal size for resize detection
      .store_terminal_size()

      # Add to history
      history <- get(".plot_history", envir = .GlobalEnv)
      history[[length(history) + 1]] <- pf
      assign(".plot_history", history, envir = .GlobalEnv)
      assign(".plot_history_idx", length(history), envir = .GlobalEnv)
    }
  }

  assign(".display_plot", .display_plot, envir = .GlobalEnv)

  # ========================================================================
  # Terminal Size Management
  # ========================================================================
  .store_terminal_size <- function() {
    cols_str <- system("tput cols", intern = TRUE, ignore.stderr = TRUE)
    lines_str <- system("tput lines", intern = TRUE, ignore.stderr = TRUE)

    if (length(cols_str) > 0 && length(lines_str) > 0) {
      assign(".last_cols", as.numeric(cols_str[1]), envir = .GlobalEnv)
      assign(".last_lines", as.numeric(lines_str[1]), envir = .GlobalEnv)
    }
  }

  assign(".store_terminal_size", .store_terminal_size, envir = .GlobalEnv)

  # ========================================================================
  # Override dev.off for automatic display
  # ========================================================================
  dev.off_original <- grDevices::dev.off
  assign("dev.off", function(...) {
    result <- dev.off_original(...)
    pf <- get(".plot_file", envir = .GlobalEnv)
    .GlobalEnv$.display_plot(pf)
    invisible(result)
  }, envir = .GlobalEnv)

  # ========================================================================
  # Plot Functions
  # ========================================================================
  # Base R plots with auto-display
  zzplot <- function(...) {
    .GlobalEnv$.create_plot_device()
    plot(...)
    dev.off()
  }

  # ggplot2 plots with auto-display
  zzggplot <- function(p) {
    .GlobalEnv$.create_plot_device()
    print(p)
    dev.off()
  }

  assign("zzplot", zzplot, envir = .GlobalEnv)
  assign("zzggplot", zzggplot, envir = .GlobalEnv)

  # ========================================================================
  # Export Functions
  # ========================================================================
  save_plot <- function(filename) {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (!is.null(pf) && file.exists(pf)) {
      file.copy(pf, filename, overwrite = TRUE)
      cat(paste("Plot saved to:", filename, "\n"))
    }
  }

  plot_to_pdf <- function(filename) {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (!is.null(pf) && file.exists(pf)) {
      if (!requireNamespace("png", quietly = TRUE)) {
        cat("Installing 'png' package...\n")
        install.packages("png", quiet = TRUE)
      }

      img <- png::readPNG(pf)
      pdf(filename, width = 9, height = 7)
      grid::grid.raster(img)
      grDevices::dev.off()
      cat(paste("PDF saved to:", filename, "\n"))
    }
  }

  assign("save_plot", save_plot, envir = .GlobalEnv)
  assign("plot_to_pdf", plot_to_pdf, envir = .GlobalEnv)

  # ========================================================================
  # Plot History Navigation
  # ========================================================================
  plot_prev <- function() {
    history <- get(".plot_history", envir = .GlobalEnv)
    idx <- get(".plot_history_idx", envir = .GlobalEnv)

    if (length(history) == 0) {
      cat("No plot history\n")
      return(invisible(NULL))
    }

    idx <- max(1, idx - 1)
    assign(".plot_history_idx", idx, envir = .GlobalEnv)
    cat(paste("Plot", idx, "of", length(history), "\n"))
    .GlobalEnv$.display_plot(history[[idx]])
  }

  plot_next <- function() {
    history <- get(".plot_history", envir = .GlobalEnv)
    idx <- get(".plot_history_idx", envir = .GlobalEnv)

    if (length(history) == 0) {
      cat("No plot history\n")
      return(invisible(NULL))
    }

    idx <- min(length(history), idx + 1)
    assign(".plot_history_idx", idx, envir = .GlobalEnv)
    cat(paste("Plot", idx, "of", length(history), "\n"))
    .GlobalEnv$.display_plot(history[[idx]])
  }

  plot_history <- function() {
    history <- get(".plot_history", envir = .GlobalEnv)
    idx <- get(".plot_history_idx", envir = .GlobalEnv)

    if (length(history) == 0) {
      cat("No plot history\n")
      return(invisible(NULL))
    }

    cat(paste("Plot history:", length(history), "plots\n"))
    cat(paste("Current: Plot", idx, "\n\n"))
    for (i in seq_along(history)) {
      marker <- if (i == idx) "* " else "  "
      cat(paste(marker, "[", i, "]", " ", history[[i]], "\n", sep = ""))
    }
  }

  assign("plot_prev", plot_prev, envir = .GlobalEnv)
  assign("plot_next", plot_next, envir = .GlobalEnv)
  assign("plot_history", plot_history, envir = .GlobalEnv)

  # ========================================================================
  # Configuration Functions
  # ========================================================================
  set_plot_size <- function(width = 900, height = 700, res = 96) {
    assign(".plot_width", width, envir = .GlobalEnv)
    assign(".plot_height", height, envir = .GlobalEnv)
    assign(".plot_res", res, envir = .GlobalEnv)
    cat(paste("Plot size set to", width, "x", height, "@ ", res, "dpi\n", sep = ""))
  }

  set_plot_align <- function(align = "right") {
    valid_aligns <- c("left", "center", "right")
    if (!(align %in% valid_aligns)) {
      cat(paste("Valid alignments:", paste(valid_aligns, collapse = ", "), "\n"))
      return(invisible(NULL))
    }
    # Note: iTerm2 doesn't support alignment, only Kitty does
    assign(".plot_align", align, envir = .GlobalEnv)
    cat(paste("Plot alignment set to:", align, "\n"))
  }

  set_plot_mode <- function(mode = "pane") {
    valid_modes <- c("inline", "pane", "auto")
    if (!(mode %in% valid_modes)) {
      cat(paste("Valid modes:", paste(valid_modes, collapse = ", "), "\n"))
      cat("  inline: display in current terminal\n")
      cat("  pane:   display in dedicated kitty pane (reused)\n")
      cat("  auto:   try inline, fall back to pane\n")
      return(invisible(NULL))
    }
    assign(".plot_display_mode", mode, envir = .GlobalEnv)
    cat(paste("Plot display mode set to:", mode, "\n"))
  }

  # Close the plot pane if it exists
  close_plot_pane <- function() {
    pane_title <- get(".plot_pane_title", envir = .GlobalEnv)
    if (.kitty_window_exists(pane_title)) {
      system(paste0("kitty @ close-window --match title:", pane_title),
             ignore.stderr = TRUE, ignore.stdout = TRUE)
      cat("Plot pane closed\n")
    } else {
      cat("No plot pane open\n")
    }
  }

  assign("set_plot_mode", set_plot_mode, envir = .GlobalEnv)
  assign("close_plot_pane", close_plot_pane, envir = .GlobalEnv)

  set_plot_size_relative <- function(width_pct = 0.4, height_pct = 0.75) {
    assign(".use_relative_sizing", TRUE, envir = .GlobalEnv)
    assign(".width_pct", width_pct, envir = .GlobalEnv)
    assign(".height_pct", height_pct, envir = .GlobalEnv)
    assign(".plot_align", "right", envir = .GlobalEnv)

    cols_str <- system("tput cols", intern = TRUE, ignore.stderr = TRUE)
    lines_str <- system("tput lines", intern = TRUE, ignore.stderr = TRUE)

    if (length(cols_str) > 0 && length(lines_str) > 0) {
      cols <- as.numeric(cols_str[1])
      lines <- as.numeric(lines_str[1])
      width <- floor(cols * 8 * width_pct)
      height <- floor(lines * 16 * height_pct)
      cat(paste("Relative sizing enabled:", width, "x", height, "px\n"))
      cat(paste("(", width_pct * 100, "% x ", height_pct * 100, "% of terminal)\n", sep = ""))
      cat("Plots will auto-resize when terminal is resized\n")
    }
  }

  plot_redisplay_if_resized <- function() {
    cols_str <- system("tput cols", intern = TRUE, ignore.stderr = TRUE)
    lines_str <- system("tput lines", intern = TRUE, ignore.stderr = TRUE)

    if (length(cols_str) == 0 || length(lines_str) == 0) {
      cat("Could not determine terminal size\n")
      return(invisible(NULL))
    }

    cols <- as.numeric(cols_str[1])
    lines <- as.numeric(lines_str[1])
    last_cols <- get(".last_cols", envir = .GlobalEnv)
    last_lines <- get(".last_lines", envir = .GlobalEnv)

    if (is.null(last_cols) || is.null(last_lines)) {
      cat("No previous plot to redisplay\n")
      return(invisible(NULL))
    }

    if (cols != last_cols || lines != last_lines) {
      cat(paste("Terminal resized from", last_cols, "x", last_lines, "to", cols, "x", lines, "\n"))
      cat("Redisplaying current plot...\n")

      pf <- get(".plot_file", envir = .GlobalEnv)
      if (!is.null(pf) && file.exists(pf)) {
        .GlobalEnv$.display_plot(pf)
      }
    }
  }

  assign("set_plot_size", set_plot_size, envir = .GlobalEnv)
  assign("set_plot_align", set_plot_align, envir = .GlobalEnv)
  assign("set_plot_size_relative", set_plot_size_relative, envir = .GlobalEnv)
  assign("plot_redisplay_if_resized", plot_redisplay_if_resized, envir = .GlobalEnv)

  # ========================================================================
  # Zoom Functions (for teaching/presentations)
  # ========================================================================
  plot_zoom <- function() {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (is.null(pf) || !file.exists(pf)) {
      cat("No plot to display\n")
      return(invisible(NULL))
    }
    if (.is_docker()) {
      cat("In Docker: use :RPlotPreview in vim to open in Preview\n")
      return(invisible(NULL))
    }
    system2("open", pf, wait = FALSE)
    cat("Opened in Preview - use Cmd++ to zoom, Cmd+0 to fit\n")
    invisible(NULL)
  }

  plot_zoom_kitty <- function() {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (is.null(pf) || !file.exists(pf)) {
      cat("No plot to display\n")
      return(invisible(NULL))
    }
    terminal <- get(".terminal", envir = .GlobalEnv)
    if (terminal != "kitty") {
      cat("plot_zoom_kitty() requires Kitty terminal\n")
      return(invisible(NULL))
    }
    system(paste("kitty @ launch --type=os-window",
                 "kitty +kitten icat --hold --scale-up", shQuote(pf)),
           ignore.stderr = TRUE)
    cat("Opened in new Kitty window (scaled up)\n")
    invisible(NULL)
  }

  assign("plot_zoom", plot_zoom, envir = .GlobalEnv)
  assign("plot_zoom_kitty", plot_zoom_kitty, envir = .GlobalEnv)

  # ========================================================================
  # Fullscreen/Maximize Plot
  # ========================================================================
  plot_split <- function(scale = 1) {
    pf <- get(".plot_file", envir = .GlobalEnv)
    if (is.null(pf) || !file.exists(pf)) {
      cat("No plot to display\n")
      return(invisible(NULL))
    }

    # If scale != 1, create a scaled version of the plot
    display_file <- pf
    if (scale != 1) {
      if (!requireNamespace("png", quietly = TRUE)) {
        cat("Installing 'png' package for scaled display...\n")
        install.packages("png", quiet = TRUE)
      }

      # Read the current plot
      img <- png::readPNG(pf)
      dims <- dim(img)
      new_width <- floor(dims[2] * scale)
      new_height <- floor(dims[1] * scale)

      # Create scaled version
      scaled_file <- tempfile(pattern = "plot_scaled_", fileext = ".png")
      png(scaled_file, width = new_width, height = new_height, res = 96)
      par(mar = c(0, 0, 0, 0))
      grid::grid.raster(img)
      dev.off()

      display_file <- scaled_file
    }

    terminal <- get(".terminal", envir = .GlobalEnv)
    if (terminal == "kitty") {
      # Use shell wrapper to properly create split pane with kitty
      # tail -f /dev/null keeps pane open without showing a shell prompt
      shell_cmd <- sprintf(
        "exec bash -c 'kitty @ launch --location=vsplit -- sh -c \"kitty +kitten icat %s; tail -f /dev/null\"' &",
        shQuote(display_file)
      )
      # Suppress both the return code and any error messages
      tryCatch(
        invisible(system(shell_cmd, ignore.stderr = TRUE)),
        error = function(e) invisible(NULL)
      )
      cat("Plot opened in split pane (use Ctrl+Shift+] to focus plot, Ctrl+Shift+[ to return to R)\n")
    } else if (terminal == "iterm2") {
      # For iTerm2, open with system viewer
      system2("open", display_file, wait = FALSE)
      cat("Plot opened in default image viewer\n")
    }
    invisible(NULL)
  }

  assign("plot_split", plot_split, envir = .GlobalEnv)

  # ========================================================================
  # Startup Message
  # ========================================================================
  if (interactive()) {
    startup_msg <- c(
      paste("âœ“ Terminal graphics enabled (", toupper(.terminal), ")", sep = ""),
      paste("  Plot mode: pane (plots appear in dedicated kitty pane)"),
      "",
      "Quick reference:",
      "  zzplot(...)                : Base R plots (auto-display in pane)",
      "  zzggplot(p)                : ggplot2 plots (auto-display in pane)",
      "  plot_history()             : View plot history",
      "  plot_prev() / plot_next()  : Navigate history",
      "  save_plot(file)            : Save current plot as PNG",
      "  plot_to_pdf(file)          : Save current plot as PDF",
      "  set_plot_size(w,h,dpi)     : Fixed dimensions",
      "  set_plot_size_relative()   : Size by % of terminal (default: 75% x 100%)"
    )
    if (.terminal == "kitty") {
      startup_msg <- c(
        startup_msg,
        "  set_plot_mode(m)           : Display mode (pane/inline/auto)",
        "  close_plot_pane()          : Close the plot pane",
        "  set_plot_align(a)          : Alignment (left/center/right)"
      )
    }
    startup_msg <- c(
      startup_msg,
      "  plot_zoom()                : Open in Preview (Cmd++ to zoom)",
      "  plot_zoom_kitty()          : Open in new Kitty window (scaled)",
      ""
    )
    cat(paste(startup_msg, collapse = "\n"))
  }
}
